// Game state variables
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Hello</h1>
</body>

<script>
let otpTimer = null;
let otpExpiryTime = null;
let otpRequestId = null;
let gameState = {
    isAutoRunning: false,
    sessionId: null,
    msisdn: null,
    t1: null,
    t2: null,
    bossId: null,
    wave: 0,
    score: 0,
    playerInfo: null,
    data: 0,      // Data in MB
    point: 0,     // Points
    voice: 0,     // Voice minutes
    currentMode: 'HERO' // Default mode
};

const HERO_CONFIG = {
    baseScore: 100000,
    scoreMultiplier: 3,
    maxWaves: 14
};

class AccountManager {
            constructor() {
                this.accounts = JSON.parse(localStorage.getItem('anyarsar_accounts')) || [];
                this.currentAccountIndex = parseInt(localStorage.getItem('anyarsar_current_account')) || 0;
            }

            saveAccount(token, msisdn, accounts = null) {
                // Check if account already exists
                const existingIndex = this.accounts.findIndex(acc => acc.msisdn === msisdn);
                
                if (existingIndex !== -1) {
                    // Update existing account
                    this.accounts[existingIndex].token = token;
                    if (accounts) {
                        this.accounts[existingIndex].accounts = accounts;
                    }
                    this.currentAccountIndex = existingIndex;
                } else {
                    // Add new account
                    const newAccount = {
                        msisdn: msisdn,
                        token: token,
                        accounts: accounts,
                        createdAt: new Date().toISOString()
                    };
                    this.accounts.push(newAccount);
                    this.currentAccountIndex = this.accounts.length - 1;
                }
                localStorage.setItem('anyarsar_accounts', JSON.stringify(this.accounts));
                localStorage.setItem('anyarsar_current_account', this.currentAccountIndex.toString());
                
                
                
                return this.currentAccountIndex;
            }

}

document.getElementById('navPlay').addEventListener('click', function() {
                const token = localStorage.getItem('mytelToken');
                if (!token) {
                    console.log("Pleas log in first")
                    return;
                }
                
                // Auto-fill phone number from accounts if available
                const accounts = JSON.parse(localStorage.getItem('mytelAccounts') || '[]');
                if (accounts.length > 0) {
                    document.getElementById('phoneNumber').value = accounts[0].msisdn;
                }
                
                // Load saved mode preference
                loadSavedModePreference();
                
                // AUTO CLICK Initialize System Button
                setTimeout(() => {
                    const fetchTokenBtn = document.getElementById('fetchTokenBtn');
                    if (fetchTokenBtn && !fetchTokenBtn.disabled) {
                        fetchTokenBtn.click();
                    }
                }, 300);
            });

async function fetchTokenDirect(accessToken, phoneNumber) {
    try {
        const url = 'https://myidgo.mytel.com.mm/';
        const params = new URLSearchParams({
            'uuid': 'd76d97c8d3351be3a26c0f5edf00131c',
            'mcuid': '58e88a766de8a4628fd62173ac0f91c2',
            'mcapp': 'myid'
        });
        const fullUrl = `${url}?${params.toString()}`;
        
        console.log('Fetching directly from:', fullUrl);
        
        const response = await fetch(fullUrl, {
            method: 'GET',
            headers: {
                'avatar': '',
                'lang': 'en',
                'phone-number': phoneNumber,
                'access-token': accessToken,
                'User-Agent': 'Mozilla/5.0 (Linux; Android 11; Redmi Note 8 Pro Build/RP1A.200720.011; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/139.0.7258.94 Mobile Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
            }
        });
        
        if (response.ok) {
            const html = await response.text();
            
            // Token ရှာဖွေခြင်း
            const tokenMatch = html.match(/window\.token\s*=\s*"([^"]+)"/i) ||
                              html.match(/token["']?\s*[:=]\s*["']([^"']+)["']/i);
            
            if (tokenMatch && tokenMatch[1]) {
                return {
                    success: true,
                    token: tokenMatch[1]
                };
            } else {
                throw new Error('Token not found in response');
            }
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
        
    } catch (error) {
        console.error('Direct fetch error:', error);
        return {
            success: false,
            message: `Direct connection failed: ${error.message}`
        };
    }
}

async function fetchMyIDToken(token, phoneNumber, maxRetries = 10) {
    console.log('ခနစောင့်ပါ....', 'loading');
    console.log('Connecting to MyID...', 'info');

    let attempt = 0;

    while (attempt < maxRetries) {
        try {
            attempt++;
            console.log(`Attempt ${attempt}/${maxRetries}`);

            const data = await fetchTokenDirect(token, phoneNumber);

            if (data.success && data.token) {
                const extractedToken = data.token;
                window.token = extractedToken;

                console.log('Token extracted successfully');
                
                loadGatewayJS();
                return; // ✅ stop retrying
            }

            throw new Error(data.message || 'Failed to get token');

        } catch (error) {
            console.error(`Attempt ${attempt} failed:`, error.message);

            if (attempt >= maxRetries) {
                console.error('All retry attempts failed');
                throw error; // ❌ throw only after 10 attempts
            }

            // optional delay before retry
            await new Promise(res => setTimeout(res, 1000));
        }
    }
}

// function fetchMyIDToken(token, phoneNumber) {

    
//     console.log('ခနစောင့်ပါ....', 'loading');
//     console.log('Connecting to MyID...', 'info');
    
//     // တိုက်ရိုက်ချိတ်ဆက်မှုကိုသာ သုံးပါ
//     fetchTokenDirect(token, phoneNumber)
//         .then(data => {
//             if (data.success && data.token) {
//                 const extractedToken = data.token;
//                 window.token = extractedToken;
//                 console.log('Token extracted successfully');
                
//                 showPlayMessage('Connected successfully', 'success');
//                 loadGatewayJS();
//             } else {
//                 throw new Error(data.message || 'Failed to get token');
//             }
//         })
//         .catch(error => {
//             console.error('Direct connection error:', error);
            
//         });       
// }

function initializeSystem() {
            try {
                if (typeof getGameApis === 'function') {
                    window.apis = getGameApis();
                    
                    if (window.apis && typeof window.apis === 'object') {
                        console.log('APIs object received:', window.apis);
                       
                        setTimeout(() => {
                            window.systemReady();
                        }, 200);
                    } else {
                        throw new Error('getGameApis returned invalid object: ' + typeof window.apis);
                    }
                } else {
                    throw new Error('getGameApis function not found');
                }
            } catch (error) {
                
                console.log('System initialization failed: ' + error.message, 'error');
                console.error('Error initializing system:', error);
            }
}
        

// Load gateway.js
        function loadGatewayJS() {
            const gatewayScript = document.createElement('script');
            gatewayScript.src = 'gateway.js';
            gatewayScript.onload = function() {
                console.log('gateway.js loaded successfully');
                initializeSystem();
            };

                
                console.log('Failed to load gateway.js', 'error');
                console.log('Failed to load gateway.js. Please try again.', 'error');
            
        }


// document.getElementById('fetchTokenBtn').addEventListener('click', function() {
//                 const token = localStorage.getItem('mytelToken');
//                 const phoneNumber = document.getElementById('phoneNumber').value.trim();
                
//                 if (!phoneNumber) {
//                     console.log('Please enter a phone number', 'error');
//                     return;
//                 }
                
//                 if (!token) {
//                     showPlayMessage('No authentication token found. Please login again.', 'error');
//                     return;
//                 }
                
//                 this.classList.add('loading');
//                 this.disabled = true;
//                 updateSystemStatus('Initializing system...', 'loading');
                
//                 // Save recovery data before making the request
//                 saveRecoveryData(token, phoneNumber);
                
//                 fetchMyIDToken(token, phoneNumber);
//             });

const accountManager = new AccountManager();
// async function fetchAccountData(token) {
//             const apiUrl = 'https://apis.mytel.com.mm/account-detail/api/v1.2/individual/account-main?isdn=09688888888&language=en';
            
//             // Use Promise.race for timeout handling
//             const timeoutPromise = new Promise((_, reject) => 
//                 setTimeout(() => reject(new Error('Request timeout')), 10000)
//             );
            
//             const fetchPromise = fetch(apiUrl, {
//                 method: 'GET',
//                 headers: {
//                     'Authorization': `Bearer ${token}`
//                 }
//             });
            
//             Promise.race([fetchPromise, timeoutPromise])
//                 .then(response => {
//                     if (!response.ok) {
//                         throw new Error('Network response was not ok');
//                     }
//                     return response.json();
//                 })
//                 .then(data => {
                    
                    
//                     if (data.errorCode === 0) {
                        
                        
//                         // Save account to account manager
//                         if (data.result && data.result.length > 0) {
//                             const msisdn = data.result[0].msisdn;
//                             accountManager.saveAccount(token, msisdn, data.result);
//                         }

//                         return JSON.stringify(data.result);
                        
                        
                        
//                     } else {
//                         console.log(`API Error[1820]: ${data.message || 'Unknown error'}`, 'error');
//                     }
//                 })
//                 .catch(error => {
                    
//                     if (error.message === 'Request timeout') {
//                         console.log('Request timeout. Please try again.', 'error');
//                     } else {
//                         console.log('Failed to fetch account data. Please check your token and try again.', 'error');
//                     }
//                     console.error('Error:', error);
//                 });
//         }

async function fetchAccountData(token) {
    const apiUrl = 'https://apis.mytel.com.mm/account-detail/api/v1.2/individual/account-main?isdn=09688888888&language=en';
    
    try {
        // Timeout promise
        const timeoutPromise = new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Request timeout')), 10000)
        );

        // Fetch promise
        const fetchPromise = fetch(apiUrl, {
            method: 'GET',
            headers: { 'Authorization': `Bearer ${token}` }
        });

        // Wait for either fetch or timeout
        const response = await Promise.race([fetchPromise, timeoutPromise]);

        if (!response.ok) throw new Error('Network response was not ok');

        const data = await response.json();
        console.log(data)
        if (data.errorCode === 0) {
            if (data.result && data.result.length > 0) {
                const msisdn = data.result[0].msisdn;
            }
            return data.result; // ✅ now returns result to caller
        } else {
            console.log(`API Error: ${data.message || 'Unknown error'}`);
            return null;
        }

    } catch (error) {
        if (error.message === 'Request timeout') {
            console.log('Request timeout. Please try again.');
        } else {
            console.log('Failed to fetch account data. Check your token.');
        }
        console.error('Error:', error.message);
        return null; // return null on failure
    }
}

        async function sendOtpRequest(phoneNumber) {
            
            try {
                const response = await fetch('https://apis.mytel.com.mm/myid/authen/v1.0/login/method/otp/get-otp?phoneNumber=' + phoneNumber);
                
                if (response.ok) {
                    otpRequestId = phoneNumber;
                    
                    console.log('OTP sent successfully to ' + phoneNumber, 'success');
                } else {
                    throw new Error('Failed to send OTP');
                }
                
            } catch (error) {
                console.error('OTP Send Error:', error);
            }
        }


async function verifyOtpRequest(otpCode) {
            const phoneNumber = document.getElementById('phoneNumberLogin').value.trim();
            
            try {
                const response = await fetch('https://apis.mytel.com.mm/myid/authen/v1.0/login/method/otp/validate-otp', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        phoneNumber: phoneNumber,
                        password: otpCode,
                        appVersion: '1.0.93',
                        buildVersionApp: '217',
                        deviceId: '0',
                        imei: '0',
                        os: 'IPhone',
                        osAp: 'IOS',
                        version: '24.6'
                    })
                });
                
            } catch (error) {
                console.error('OTP Verify Error:', error);
                
            } 
        }

function resendOtp() {
            const phoneNumber = document.getElementById('phoneNumberLogin').value.trim();
            if (phoneNumber) {
                sendOtpRequest(phoneNumber);
            }
        }

function loadSavedModePreference() {
            const savedMode = localStorage.getItem('preferredGameMode');
            if (savedMode) {
                switchGameMode(savedMode);
            }
        }

function switchGameMode(mode) {
            if (gameState.isAutoRunning) {
                addGameLog('Please stop auto play before switching modes', 'info');
                return;
            }
            
            gameState.currentMode = mode;
            
            
            // Save mode preference to localStorage
            localStorage.setItem('preferredGameMode', mode);
        }

function processEndGamePrizes(claimedPrizes) {
            if (!claimedPrizes || !Array.isArray(claimedPrizes)) return;
            
            let totalData = 0;
            let totalPoints = 0;
            let totalVoice = 0;
            
            claimedPrizes.forEach(prize => {
                const prizeCode = prize.prizeCode;
                const amount = prize.amount || 0;
                
                if (prizeCode.includes('RD_DATA')) {
                    totalData += amount;
                    console.log(`End Game Prize: DATA ${amount}MB`, 'success');
                    
                } else if (prizeCode.includes('RD_LOYALTY')) {
                    totalPoints += amount;
                    console.log(`End Game Prize: POINTS ${amount}PTS`, 'success');
                    
                } else if (prizeCode.includes('RD_VOICE')) {
                    totalVoice += amount;
                    console.log(`End Game Prize: VOICE ${amount}MIN`, 'success');
                }
            });
            
            // Update game state
            if (totalData > 0) {
                gameState.data += totalData;
                console.log(`Total DATA earned: ${totalData}MB`, 'success');
            }
            
            if (totalPoints > 0) {
                gameState.point += totalPoints;
                console.log(`Total POINTS earned: ${totalPoints}PTS`, 'success');
            }
            
            if (totalVoice > 0) {
                gameState.voice += totalVoice;
                console.log(`Total VOICE earned: ${totalVoice}MIN`, 'success');
            }
        }

function displayPlayerInfo(playerData) {
   
    
    if (playerData && playerData.result) {
        gameState.playerInfo = playerData.result;
        
       
        return [playerData.result.goldenHeart || '0',parseInt(playerData.result.turn) || 0,parseInt(playerData.result.remainTurn) || 0,playerData.result.diamond ? 
		Number(playerData.result.diamond).toLocaleString() : '0']

        // Re-initialize phone number visibility after updating player info
        setTimeout(initPhoneNumberVisibility, 100);
    }
}

async function heartToDiamond() {
            if (!gameState.isAutoRunning) {
                
                try {
                    const result = await window?.apis?.startQuestMode('GOLDEN_HEART');
                    console.log(result);
                    if (result?.result) {
                        const sessionInfo = result.result;
                        const data = sessionInfo.t1 + "_@@_" + (sessionInfo.gameId || sessionInfo.sessionId) + "_@@_" + 5 + "_@@_" + sessionInfo.msisdn;
                        const encryptedData = await encryptRSA(data, sessionInfo.t2);

                        const _result = await window?.apis?.endGameQuestMode(encryptedData, 5, 100);
                        
                        if (_result.message) {
                            console.log('✅ Heart converted to 1500 diamonds!', 'success');
                            window.getPlayerInfo();
                        }
                    } else if (result.message === 'E10400' || result.message === 'Not enough balance to purchase') {
                        console.log('❌ You don\'t have enough money', 'error');
                    }
                    
                } catch (error) {
                    console.log('Error in heartToDiamond:', error);
                }
            }
        }

async function buyTurn() {
            if (!gameState.isAutoRunning) {
                try {
                    const result = await window.apis?.buyTurn();
                    console.log("Loading")
                    if (result.success === true) {
                        window.getPlayerInfo();
                        if (result.message) {
                            console.log(`${result.message}`, 'success');
                            console.log(`Diamond > ${result.result.diamond}`, 'success');
                            console.log(`Turn > ${result.result.amountTurn}`, 'success');
                        } else {
                            console.log(`No response`, 'error');
                        }
                    } else {
                        console.log(`${result.error.message}`, 'error');
                    }
                } catch (error) {
                    console.log(`buy turn error: ${error}`, 'error');
                    
                }
            } else {
                console.log('stop auto play first.', 'info');
                
            }
        }


async function startAutoGame(){
            if(!gameState.isAutoRunning){
                gameState.isAutoRunning=true;
                gameState.wave=0;
                gameState.score=0;

        await delay(100);
                
                // Use the current selected mode
                if (gameState.currentMode === 'HERO') {
                    addGameLog('HERO Mode auto game started','info');
                    heroGameLoop();
                } else if (gameState.currentMode === 'NORMAL') {
                    addGameLog('NORMAL Mode auto game started','info');
                    normalGameLoop();
                } else {
                    addGameLog('WORLD Mode auto game started','info');
                    gameLoop();
                }
            }else{
                stopAutoGame();
            }
        }

function stopAutoGame(){
            gameState.isAutoRunning=false; 
            console.log('Game Stop','info');
        }


async function gameLoop() {
    let consecutiveErrors = 0;
    const MAX_CONSECUTIVE_ERRORS = 3;
    
    while (gameState.isAutoRunning) {
        try {
            consecutiveErrors = 0;
            await createGame();
            
            if (!gameState.isAutoRunning) break;
            // Delay after creating game
    await delay(100);
            
            let waveSuccess = true;
            while (gameState.wave < 19 && gameState.isAutoRunning) {
                try {
                    await nextWave();
                    // Delay between nextWave and killBoss
            await delay(100);
                } catch (waveError) {
                    console.log(`Wave ${gameState.wave} error: ${waveError.message}`, 'error');
                }
                gameState.wave++;
                try {
                    const killResult = await killBoss();
                    
                    if (!gameState.isAutoRunning) break;
                    // Delay between waves (1.5 seconds)
            if (gameState.wave < 19) {
                await delay(100);
            }

                } catch (killError) {
                    if (Object.keys(killError).length === 0) {
                        console.log(`Wave ${gameState.wave} Killboss error.', 'error`);
                    } else {
                        console.log(`Wave ${gameState.wave} Killboss error: ${killError.message}`, 'error');
                    }
                    await delay(100);
                }
            }
            
            if (gameState.wave >= 19) {
                try {
                    var n = gameState.t1,
                        o = gameState.t2,
                        r = gameState.msisdn,
                        i = (gameState.sessionId, o),
                        f = Math.floor(gameState.score);
                        l = n,
                        h = "984271",
                        g = "1243";
                    
                    var v = l + "_@@_0_@@_"+ h + "_@@_"+ r + "_@@_"+ f + "_@@_" + g;
                    const b = await encryptRSA(v, i);
                    const doubleScore = (4 * gameState.score).toString();
                    const tripleH = (3 * parseInt(h)).toString();
                    console.log('Ending game', 'info');
                    const endResult =await window.apis?.createEndGame(b, doubleScore, tripleH);

                    if (endResult && endResult.success && endResult.result && endResult.result.claimedPrizes) {
                        processEndGamePrizes(endResult.result.claimedPrizes);
                        console.log('Game completed successfully.', 'success');
                            } else {
                                addGameLog('Game completed but no prizes received', 'info');
                            }
                        } catch (endError) {
                            if (endError.message.includes('timeout')) {
                                console.log('End game request timeout', 'error');
                            } else {
                                console.log(`End game error: ${endError.message}`, 'error');
                            }
                        }
                
                gameState.wave = 0;
                gameState.score = 0;
                
            }
        } catch (error) {
            consecutiveErrors++;
            console.log(`Game loop error: ${error.message}`, 'error');
            
            if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                console.log(`Too many consecutive errors (${consecutiveErrors}), stopping auto game`, 'error');
                stopAutoGame();
                break;
            }
            
            const waitTime = 2000 * consecutiveErrors;
            console.log(`Waiting ${waitTime/1000} seconds before retry...`, 'info');
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
    }
}


async function encryptRSA(plaintext, publicKeyBase64) {
        return new Promise((resolve, reject) => {
            try {
                const publicKeyPem = "-----BEGIN PUBLIC KEY-----\r\n" + 
                                    publicKeyBase64 + 
                                    "\r\n-----END PUBLIC KEY-----";

                const encryptor = new JSEncrypt();
                encryptor.setPublicKey(publicKeyPem);
                
                const encrypted = encryptor.encrypt(plaintext);
                
                if (encrypted) {
                    resolve(encrypted);
                } else {
                    reject(new Error("Encryption failed - possibly invalid public key"));
                }
            } catch (error) {
                console.error("Encryption error:", error);
                reject(error);
            }
        });
    }

// Alternative approach: Direct decrease without API call (if API is slow)
function decreaseTurnsImmediately() {
    const totalTurnElement = document.getElementById('totalTurn');
    const remainTurnElement = document.getElementById('remainTurn');
    
    if (totalTurnElement && remainTurnElement) {
        let currentTotal = parseInt(totalTurnElement.textContent) || 0;
        let currentRemain = parseInt(remainTurnElement.textContent) || 0;
        
        if (currentTotal > 0 && currentRemain > 0) {
            currentTotal = Math.max(0, currentTotal - 1);
            currentRemain = Math.max(0, currentRemain - 1);
            
            totalTurnElement.textContent = currentTotal;
            remainTurnElement.textContent = currentRemain;
            
            
        }
    }
}


async function createGame() {
     addGameLog('Creating new game...', 'info');
    
    try {
        gameState.bossId = null;
        
        // Decrease turns immediately
        decreaseTurnsImmediately();
		
		// Get selected hero from localStorage or use default
        const selectedHero = localStorage.getItem('selectedHero') || 'LUCUS';
        
        const result = await window.apis?.createGame("WORLD", selectedHero) || {
            success: true,
            result: {
                sessionId: 'session_' + Date.now(),
                msisdn: gameState.msisdn || '09688888888',
                t1: 't1_' + Math.random().toString(36).substring(2),
                t2: 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA' + Math.random().toString(36).substring(2)
            }
        };
        
        if (result.success) {
            gameState.sessionId = result.result.sessionId;
            gameState.msisdn = result.result.msisdn;
            gameState.t1 = result.result.t1;
            gameState.t2 = result.result.t2;
            gameState.wave = 0;
            gameState.score = 0;
			 addGameLog(`Game created successfully with hero: ${selectedHero}`, 'success');
            return true;
        } else {
            throw new Error(`Create game failed: ${result.message}`);
        }
    } catch (error) {
        addGameLog(`Create game error: ${error.message}`, 'error');
        throw error;
    }
}

 async function nextWave() {
            try {
                const result = await window.apis?.nextWave(gameState.wave.toString(), "WORLD") || {
                    success: true,
                    result: {
                        bossIds: ['boss_' + Math.random().toString(36).substring(2)]
                    }
                };
                
                if (result.success) {
                    if (result.result.bossIds && result.result.bossIds.length > 0) {
                        gameState.bossId = result.result.bossIds[0];
                        return true;
                    } else {
                        throw new Error('No boss IDs returned from server');
                    }
                } else {
                    throw new Error(`Next wave failed: ${result.message}`);
                }
            } catch (error) {
                addGameLog(`Next wave error: ${error.message}`, 'error');
                gameState.sessionId = null;
                throw error;
            }
        }
        
        async function killBoss() {
            if (!gameState.bossId || gameState.bossId.trim() === '') {
                addGameLog('Invalid boss ID, recreating game...', 'error');
                gameState.sessionId = null;
                return false;
            }
            
            if (!gameState.t1 || !gameState.t2 || !gameState.sessionId || !gameState.msisdn) {
                addGameLog('Missing required game state parameters', 'error');
                return false;
            }
            
            if (gameState.wave === 0) {
                gameState.score = 577;
            } else {
                gameState.score += 9800;
            }
            
            const U = `${gameState.t1}_@@_${gameState.sessionId}_@@_${gameState.msisdn}_@@_${gameState.score}_@@_${gameState.t1}`;
            
            try {
                const j = await encryptRSA(U, gameState.t2);
                const bossIdString = Array.isArray(gameState.bossId) ? gameState.bossId[0] : gameState.bossId;
                const doubleScore = (2 * gameState.score).toString();
                
                const result = await window.apis?.killBoss(j, doubleScore, bossIdString, "WORLD") || {
                    success: true,
                    result: {
                        prizeCode: 'RD_DATA_100MB'
                    }
                };
                
                if (result.success) {
                    const prizeCode = result.result.prizeCode ? result.result.prizeCode : 'No prize';
                    const processedPrize = simplePrizeProcessor(prizeCode);
                    addGameLog(`Wave ${gameState.wave} Prize: ${processedPrize}`, 'success');
                    
                    // Show prize image for data and points
                    if (prizeCode.includes('RD_DATA')) {
                        const amount = prizeCode.split('_').pop().replace('MB', '');
                        showPrizeModal('data', amount);
                    } else if (prizeCode.includes('RD_LOYALTY')) {
                        const amount = prizeCode.split('_').pop().replace('PTS', '');
                        showPrizeModal('point', amount);
                    }
                    
                    return true;
                } else {
                    if (result.message && (result.message.includes('Session ID is not OK')) || result.message && (result.message.includes('invalid response was received from'))) {
                        stopAutoGame();
                        showPlayMessage(' Auto Play ကိုပြန်နှိပ်ပါ', 'error');
                        return false;
                    } else {
                        return false;
                    }
                }
                
            } catch (error) {
                addGameLog(`Kill boss failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function heroCreateGame() {
            addGameLog('Creating HERO game...','info');
            try {
                gameState.bossId = null;
				decreaseTurnsImmediately();
				// Get selected hero
        const selectedHero = localStorage.getItem('selectedHero') || 'LUCUS';
                const result = await window.apis?.createGame('HERO',selectedHero);
                if (result && result.success) {
                    gameState.sessionId = result.result.sessionId;
                    gameState.msisdn   = result.result.msisdn;
                    gameState.t1       = result.result.t1;
                    gameState.t2       = result.result.t2;
                    gameState.wave     = 0;
                    // initialise score to the HERO base value
                    gameState.score    = HERO_CONFIG.baseScore;
                    addGameLog(`HERO game created successfully with hero: ${selectedHero}`,'success');
                    return true;
                }
                throw new Error(result && result.message ? String(result.message) : 'Unknown error');
            } catch (e) {
                addGameLog(`Create game error: ${e.message}`,'error');
                throw e;
            }
        }

        async function heroNextWave() {
            try {
                // update score based on whether this is the first wave or a later one
                gameState.score = (gameState.wave === 0) ? HERO_CONFIG.baseScore : gameState.score * HERO_CONFIG.scoreMultiplier;
                const result = await window.apis?.nextWave(gameState.score.toString(),'HERO');
                if (result && result.success && result.result && Array.isArray(result.result.bossIds) && result.result.bossIds.length > 0) {
                    gameState.bossId = result.result.bossIds[0];
                    return true;
                }
                throw new Error('No boss IDs returned from server');
            } catch (e) {
                addGameLog(`Next wave error: ${e.message}`,'error');
                gameState.sessionId = null;
                throw e;
            }
        }

        async function heroKillBoss() {
            if (!gameState.bossId) {
                addGameLog('Invalid boss ID, recreating game...','error');
                gameState.sessionId = null;
                return false;
            }
            const U = `${gameState.t1}_@@_${gameState.sessionId}_@@_${gameState.msisdn}_@@_${gameState.score}_@@_${gameState.t1}`;
            try {
                const j   = await encryptRSA(U, gameState.t2);
                const bid = Array.isArray(gameState.bossId) ? gameState.bossId[0] : gameState.bossId;
                const ds  = (2 * gameState.score).toString();
                const result = await window.apis?.killBoss(j, ds, bid, 'HERO');
                if (result && result.success) {
                    const prizeCode = (result.result && result.result.prizeCode) ? result.result.prizeCode : 'No prize';
                    const processed = simplePrizeProcessor(prizeCode);
                    addGameLog(`Wave ${gameState.wave} Prize: ${processed}`,'success');
                    // show prize via existing helper if available
                    try { if (typeof detectAndShowPrize === 'function') detectAndShowPrize(prizeCode); } catch(_){}
                    return true;
                }
                if (result && result.message && result.message.includes('Session ID is not OK')) {
                    stopAutoGame();
                    showPlayMessage(' Auto Play ကိုပြန်နှိပ်ပါ','error');
                    return false;
                }
                return false;
            } catch (e) {
                addGameLog(`Kill boss failed: ${e.message}`,'error');
                return false;
            }
        }

        async function heroEndGame() {
            const encData = await encryptRSA(`${gameState.t1}_@@_0_@@_984271_@@_${gameState.msisdn}_@@_${Math.floor(gameState.score)}_@@_1243`, gameState.t2);
            return await window.apis?.createEndGame(encData, (4 * gameState.score).toString(), (3 * 984271).toString());
        }

        async function heroGameLoop() {
            let consecutiveErrors = 0;
            const MAX_ERRORS = 3;
            while (gameState.isAutoRunning) {
                try {
                    consecutiveErrors = 0;
                    await heroCreateGame();
                    if (!gameState.isAutoRunning) break;
					// Delay after creating game
            await delay(100);
                    for (let wave = 1; wave <= HERO_CONFIG.maxWaves && gameState.isAutoRunning; wave++) {
                        try {
                            await heroNextWave();
                            gameState.wave = wave;
							// Delay between nextWave and killBoss
                    await delay(100);
                            await heroKillBoss();
							// Delay between waves (1.5 seconds)
                    if (wave < HERO_CONFIG.maxWaves) {
                        await delay(100);
                    }
                        } catch (waveErr) {
                            addGameLog(`Wave ${wave} error: ${waveErr.message}`,'error');
							await delay(100);
                        }
                    }
                    if (gameState.wave >= HERO_CONFIG.maxWaves) {
                        try {
                            const endRes = await heroEndGame();
                            if (endRes && endRes.success && endRes.result && endRes.result.claimedPrizes) {
                                processEndGamePrizes(endRes.result.claimedPrizes);
                                addGameLog('HERO Game completed successfully.','success');
                            }
                        } catch (endErr) {
                            addGameLog(`End game error: ${endErr.message}`,'error');
                        }
                        // reset for next loop
                        gameState.wave  = 0;
                        gameState.score = 0;
						// Delay before starting next game
                await delay(100);
                    }
                } catch (loopErr) {
                    consecutiveErrors++;
                    addGameLog(`Game loop error: ${loopErr.message}`,'error');
                    if (consecutiveErrors >= MAX_ERRORS) {
                        addGameLog('Too many consecutive errors, stopping auto game','error');
                        stopAutoGame();
                        break;
                    }
                    const waitTime = 2000 * consecutiveErrors;
                    await new Promise(res => setTimeout(res, waitTime));
                }
            }
        }
        
        function getScore(wave) {
            return 14366 * wave;
        }

        function rsaPayloadEncrypt(t1, t2, parts) {
            const payload = parts.join('_@@_');
            return encryptRSA(payload, t2);
        }

        // Normal Mode Game Functions
        async function normalCreateGame() {
            gameState.currentGameMode = 'Normal Mode';
            addGameLog('Creating NORMAL game...','info');
            try {
                gameState.bossId = null;
				decreaseTurnsImmediately();
				// Get selected hero
        const selectedHero = localStorage.getItem('selectedHero') || 'LUCUS';
                const result = await window.apis?.createGame('NORMAL',selectedHero);
                if (result && result.success) {
                    gameState.sessionId = result.result.sessionId;
                    gameState.msisdn   = result.result.msisdn;
                    gameState.t1       = result.result.t1;
                    gameState.t2       = result.result.t2;
                    gameState.wave     = 0;
                    gameState.score    = 0;
                    addGameLog('NORMAL game created successfully with hero: ${selectedHero}','success');
                    return true;
                }
                throw new Error(result && result.message ? String(result.message) : 'Unknown error');
            } catch (e) {
                addGameLog(`Create game error: ${e.message}`,'error');
                throw e;
            }
        }

        async function normalNextWave(wave) {
            try {
                const ii = wave + 200;
                const waveScore = getScore(10 * ii + 500);
                const result = await window.apis?.nextWave(waveScore, 'NORMAL');
                if (result && result.success && result.result && Array.isArray(result.result.bossIds) && result.result.bossIds.length > 0) {
                    gameState.bossId = result.result.bossIds[0];
                    return true;
                }
                throw new Error('No boss IDs returned from server');
            } catch (e) {
                addGameLog(`Next wave error: ${e.message}`,'error');
                gameState.sessionId = null;
                throw e;
            }
        }

        async function normalKillBoss(wave) {
            if (!gameState.bossId) {
                addGameLog('Invalid boss ID, recreating game...','error');
                gameState.sessionId = null;
                return false;
            }
            const killScore = getScore(2 * wave + 1);
            const U = `${gameState.t1}_@@_${gameState.sessionId}_@@_${gameState.msisdn}_@@_${killScore}_@@_${gameState.t1}`;
            try {
                const j   = await encryptRSA(U, gameState.t2);
                const bid = Array.isArray(gameState.bossId) ? gameState.bossId[0] : gameState.bossId;
                const ds  = (2 * killScore).toString();
                const result = await window.apis?.killBoss(j, ds, bid, 'NORMAL');
                if (result && result.success) {
                    const prizeCode = (result.result && result.result.prizeCode) ? result.result.prizeCode : 'No prize';
                    const processed = simplePrizeProcessor(prizeCode);
                    addGameLog(`Wave ${wave} Prize: ${processed}`,'success');
                    try { if (typeof detectAndShowPrize === 'function') detectAndShowPrize(prizeCode); } catch(_){}
                    return true;
                }
                if (result && result.message && result.message.includes('Session ID is not OK')) {
                    stopAutoGame();
                    showPlayMessage(' Auto Play ကိုပြန်နှိပ်ပါ','error');
                    return false;
                }
                return false;
            } catch (e) {
                addGameLog(`Kill boss failed: ${e.message}`,'error');
                return false;
            }
        }

        async function normalEndGame() {
            const gold = 3000000;
            const fgold = String(3 * gold);
            const scoreEnd = getScore(14);
            const fiscore = String(4 * scoreEnd);
            const payload2 = `${gameState.t1}_@@_0_@@_${gold}_@@_${gameState.msisdn}_@@_${scoreEnd}_@@_1`;
            const encpayload2 = await encryptRSA(payload2, gameState.t2);
            const endRes = await window.apis?.createEndGame(encpayload2, fiscore, fgold);
            return endRes;
        }

        async function normalGameLoop() {
            let consecutiveErrors = 0;
            const MAX_ERRORS = 3;
            while (gameState.isAutoRunning) {
                try {
                    consecutiveErrors = 0;
                    await normalCreateGame();
                    if (!gameState.isAutoRunning) break;
					// Delay after creating game
            await delay(100);
                    for (let wave = 0; wave < 9 && gameState.isAutoRunning; wave++) {
                        try {
                            await normalNextWave(wave);
							// Delay between nextWave and killBoss
                    await delay(100);
                            await normalKillBoss(wave);
							// Delay between waves (1.5 seconds)
                    if (wave < 8) {
                        await delay(100);
                    }
                        } catch (waveErr) {
                            addGameLog(`Wave ${wave} error: ${waveErr.message}`,'error');
							await delay(100);
                        }
                    }
                    if (gameState.wave >= 9) {
                        try {
                            const endRes = await normalEndGame();
                            if (endRes && endRes.success && endRes.result && endRes.result.claimedPrizes) {
                                processEndGamePrizes(endRes.result.claimedPrizes);
                                addGameLog('NORMAL Game completed successfully.','success');
                            }
                        } catch (endErr) {
                            addGameLog(`End game error: ${endErr.message}`,'error');
                        }
                        gameState.wave  = 0;
                        gameState.score = 0;
                    }
                } catch (loopErr) {
                    consecutiveErrors++;
                    addGameLog(`Game loop error: ${loopErr.message}`,'error');
                    if (consecutiveErrors >= MAX_ERRORS) {
                        addGameLog('Too many consecutive errors, stopping auto game','error');
                        stopAutoGame();
                        break;
                    }
                    const waitTime = 2000 * consecutiveErrors;
                    await new Promise(res => setTimeout(res, waitTime));
                }
            }
        }

        function simplePrizeProcessor(prizeCode) {
            if (!prizeCode) return 'No prize';
            
            let result = prizeCode
                .replace('RD_', '')
                .replace(/_/g, ' - ')
                .replace('DATA', 'Mobile Data')
                .replace('LOYALTY', 'Loyalty Points')
                .replace('DIA', 'Diamonds')
                .replace('VOICE', 'Voice Minutes')
                .replace('SMS', 'SMS')
                .replace('S1', 'SIM 1')
                .replace('STAR', '⭐Stars');
            
            if (result.includes('Mobile Data') && !result.includes('MB')) {
                result += ' MB';
            }
            if (result.includes('S1') || result.includes('S2')|| result.includes('S3')|| result.includes('S4')|| result.includes('S5')|| result.includes('S6')|| result.includes('S7')|| result.includes('S8')|| result.includes('S9')) {
                result = result.replace('S', 'SIM ');
            }
            
            return result;
        }

window.changeLanguage = function() {
setTimeout(() => {
    if (window.apis && typeof window.apis.setLanguage === 'function') {
        window.apis.setLanguage('my').then(result => {
        }).catch(error => {
        });
    } 
}, 300);
}


window.getPlayerInfo = function() {
setTimeout(() => {
    if (window.apis && typeof window.apis.getPlayerInfo === 'function') {
        window.apis.getPlayerInfo().then(result => {
            displayPlayerInfo(result);
        }).catch(error => {
            console.log('Error getting player info:', error);
        });
    } 

}, 100);
}


if (typeof window.apis.buyTicketCreateGame !== 'function') {
    window.apis.buyTicketCreateGame = async function(mode) {
        // Mock implementation - replace with actual API call
        return {
            success: true,
            result: {
                sessionId: 'session_' + Date.now(),
                gameId: 'game_' + Date.now(),
                msisdn: gameState.msisdn || '09666666666',
                t1: 't1_' + Math.random().toString(36).substring(2),
                t2: 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA' + Math.random().toString(36).substring(2)
            }
        };
    };
}

if (typeof window.apis.killBossBounceQuestE !== 'function') {
    window.apis.killBossBounceQuestE = async function(encryptedData) {
        // Mock implementation - replace with actual API call
        return {
            success: true,
            code: Math.random() > 0.8 ? 'OVER_AMOUNT_PRIZE_PER_TURN' : 'CONTINUE',
            result: {
                prizeCode: 'RD_DATA_100MB'
            }
        };
    };
}

if (typeof window.apis.endGameBounceQuestNb !== 'function') {
    window.apis.endGameBounceQuestNb = async function(encryptedData, damage) {
        // Mock implementation - replace with actual API call
        return {
            success: true,
            result: {
                numTurn: 10,
                rank: 1,
                prizes: [
                    { prizeCode: 'RD_DATA_500MB', amount: 500 }
                ]
            }
        };
    };
}
</script>
</html>